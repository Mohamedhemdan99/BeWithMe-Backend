<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Twilio Video Call Test</title>
    <script src="https://sdk.twilio.com/js/video/releases/2.26.0/twilio-video.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }

        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        input, button, select {
            padding: 8px;
            font-size: 16px;
        }

        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            padding: 10px 15px;
        }

            button:hover {
                background-color: #45a049;
            }

            button:disabled {
                background-color: #cccccc;
                cursor: not-allowed;
            }

        .call-controls {
            display: none;
            margin-top: 20px;
        }

        #end-call-btn {
            background-color: #f44336;
        }

            #end-call-btn:hover {
                background-color: #d32f2f;
            }

        .video-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }

        .video-item {
            width: 320px;
            border: 1px solid #ccc;
            border-radius: 8px;
            overflow: hidden;
        }

            .video-item video {
                width: 100%;
                height: 240px;
                background-color: #222;
            }

        .video-label {
            padding: 8px;
            text-align: center;
            background-color: #f5f5f5;
            font-weight: bold;
        }

        .status-bar {
            margin-top: 20px;
            padding: 10px;
            border-radius: 4px;
            background-color: #f5f5f5;
        }

        .log-container {
            margin-top: 20px;
            border: 1px solid #ccc;
            border-radius: 4px;
            height: 150px;
            overflow-y: auto;
            padding: 10px;
            background-color: #f5f5f5;
        }

        .log-entry {
            margin-bottom: 5px;
            font-family: monospace;
        }

        .alert {
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid transparent;
            border-radius: 4px;
        }

        .alert-warning {
            color: #856404;
            background-color: #fff3cd;
            border-color: #ffeeba;
        }

        .alert-info {
            color: #0c5460;
            background-color: #d1ecf1;
            border-color: #bee5eb;
        }

        .device-selection {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .test-media-btn {
            background-color: #007bff;
            margin-right: 10px;
        }

            .test-media-btn:hover {
                background-color: #0069d9;
            }
    </style>
</head>
<body>
    <div class="container">
        <h1>Twilio Video Call Test</h1>

        <div id="browser-check" class="alert alert-info">
            Checking browser compatibility...
        </div>

        <div class="device-selection">
            <h2>Media Device Selection</h2>
            <div class="form-group">
                <label for="audio-input-select">Microphone:</label>
                <select id="audio-input-select">
                    <option value="">Loading audio devices...</option>
                </select>
            </div>
            <div class="form-group">
                <label for="video-input-select">Camera:</label>
                <select id="video-input-select">
                    <option value="">Loading video devices...</option>
                </select>
            </div>
            <button id="test-media-btn" class="test-media-btn">Test Audio/Video</button>
            <button id="refresh-devices-btn">Refresh Device List</button>
        </div>

        <div id="test-media-container" style="display: none;">
            <h3>Device Test</h3>
            <div class="video-item">
                <div id="test-media"></div>
                <div class="video-label">Test Video</div>
            </div>
            <button id="stop-test-btn">Stop Test</button>
        </div>

        <div class="form-container">
            <h2>Initiate Video Call</h2>
            <div class="form-group">
                <label for="post-id">Post ID:</label>
                <input type="number" id="post-id" placeholder="Enter Post ID" value="1" required>
            </div>
            <div class="form-group">
                <label for="acceptor-id">Acceptor ID:</label>
                <input type="text" id="acceptor-id" placeholder="Enter Acceptor ID" value="8bfd76fa-a316-4f4c-ac43-2a1dd76c34c0" required>
            </div>
            <button id="initiate-call-btn">Initiate Call</button>
        </div>

        <div class="call-controls" id="call-controls">
            <h2>Call In Progress</h2>
            <button id="end-call-btn">End Call</button>
            <button id="toggle-audio-btn">Mute Audio</button>
            <button id="toggle-video-btn">Turn Off Video</button>
        </div>
        <!-- Add this to your HTML -->
        <div class="form-container" id="join-call-section">
            <h2>Join Existing Call</h2>
            <div class="form-group">
                <label for="room-name-input">Room Name:</label>
                <input type="text" id="room-name-input" placeholder="Enter Room Name" required>
            </div>
            <button id="join-call-btn">Join Call</button>
        </div>

        <div class="status-bar" id="status-bar">
            Status: Checking device availability...
        </div>

        <div class="video-container">
            <div class="video-item">
                <div id="local-media"></div>
                <div class="video-label">You (Local)</div>
            </div>
            <div class="video-item">
                <div id="remote-media"></div>
                <div class="video-label">Remote Participant</div>
            </div>
        </div>

        <div class="log-container">
            <h3>Activity Log</h3>
            <div id="log"></div>
        </div>
    </div>

    <script>
        // DOM Elements
        const postIdInput = document.getElementById('post-id');
        const acceptorIdInput = document.getElementById('acceptor-id');
        const initiateCallBtn = document.getElementById('initiate-call-btn');
        const endCallBtn = document.getElementById('end-call-btn');
        const toggleAudioBtn = document.getElementById('toggle-audio-btn');
        const toggleVideoBtn = document.getElementById('toggle-video-btn');
        const callControls = document.getElementById('call-controls');
        const statusBar = document.getElementById('status-bar');
        const logContainer = document.getElementById('log');
        const localMediaContainer = document.getElementById('local-media');
        const remoteMediaContainer = document.getElementById('remote-media');
        const browserCheckDiv = document.getElementById('browser-check');
        const audioInputSelect = document.getElementById('audio-input-select');
        const videoInputSelect = document.getElementById('video-input-select');
        const testMediaBtn = document.getElementById('test-media-btn');
        const refreshDevicesBtn = document.getElementById('refresh-devices-btn');
        const testMediaContainer = document.getElementById('test-media-container');
        const testMediaDiv = document.getElementById('test-media');
        const stopTestBtn = document.getElementById('stop-test-btn');

        // Global variables
        let room = null;
        let accessToken = null;
        let localTracks = [];
        let testTracks = [];
        let isAudioEnabled = true;
        let isVideoEnabled = true;

        // Log function
        function log(message) {
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
            console.log(message);
        }

        // Update status
        function updateStatus(message) {
            statusBar.textContent = `Status: ${message}`;
            log(message);
        }

        // Check browser compatibility
        function checkBrowserCompatibility() {
            const isWebRTCSupported = (navigator.mediaDevices && 'getUserMedia' in navigator.mediaDevices);

            if (!isWebRTCSupported) {
                browserCheckDiv.className = 'alert alert-warning';
                browserCheckDiv.textContent = 'Warning: Your browser may not fully support WebRTC required for video calls. Please use Chrome, Firefox, or Edge for best results.';
                return false;
            }

            browserCheckDiv.className = 'alert alert-info';
            browserCheckDiv.textContent = 'Your browser supports WebRTC technology needed for video calls.';
            return true;
        }

        // Populate available media devices
        async function getAvailableMediaDevices() {
            try {
                // Request audio and video permissions separately
                await navigator.mediaDevices.getUserMedia({ audio: true });
            } catch (audioError) {
                log(`Unable to access audio: ${audioError.message}`);
            }

            try {
                await navigator.mediaDevices.getUserMedia({ video: true });
            } catch (videoError) {
                log(`Unable to access video: ${videoError.message}`);
            }

            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                // Rest of the code to populate devices...
                // Clear existing options
                audioInputSelect.innerHTML = '';
                videoInputSelect.innerHTML = '';

                // Populate audio devices
                const audioDevices = devices.filter(d => d.kind === 'audioinput');
                if (audioDevices.length === 0) {
                    audioInputSelect.innerHTML = '<option value="">No microphone found</option>';
                } else {
                    audioDevices.forEach(device => {
                        const option = document.createElement('option');
                        option.value = device.deviceId;
                        option.text = device.label || `Microphone ${audioInputSelect.length + 1}`;
                        audioInputSelect.appendChild(option);
                    });
                }

                // Populate video devices
                const videoDevices = devices.filter(d => d.kind === 'videoinput');
                if (videoDevices.length === 0) {
                    videoInputSelect.innerHTML = '<option value="">No camera found</option>';
                } else {
                    videoDevices.forEach(device => {
                        const option = document.createElement('option');
                        option.value = device.deviceId;
                        option.text = device.label || `Camera ${videoInputSelect.length + 1}`;
                        videoInputSelect.appendChild(option);
                    });
                }

                updateStatus('Media devices detected');
            } catch (error) {
                updateStatus(`Error accessing devices: ${error.message}`);
                // Handle dropdown errors...
            }
        }
        // Test media devices
        // In testMediaDevices and connectToRoom functions:
        async function testMediaDevices() {
            try {
                stopMediaTest();
                const audioDeviceId = audioInputSelect.value;
                const videoDeviceId = videoInputSelect.value;

                const constraints = {
                    audio: audioDeviceId ? { deviceId: { exact: audioDeviceId } } : false,
                    video: videoDeviceId ? { deviceId: { exact: videoDeviceId }, width: 640, height: 480 } : false
                };

                // Fallback if no devices selected
                if (!constraints.audio && !constraints.video) {
                    throw new Error('No devices selected');
                }

                testTracks = await Twilio.Video.createLocalTracks(constraints);
                // Rest of the code...
            } catch (error) {
                if (error.name === 'NotFoundError') {
                    updateStatus('Selected device not found. Please refresh devices.');
                }
                // Handle other errors...
            }
        }

        // Stop media test
        function stopMediaTest() {
            testTracks.forEach(track => {
                track.stop();
                track.detach().forEach(element => element.remove());
            });
            testTracks = [];
            testMediaDiv.innerHTML = '';
            testMediaContainer.style.display = 'none';
        }

        // Initialize the page
        async function init() {
            updateStatus('Initializing...');

            // Check browser compatibility
            checkBrowserCompatibility();

            // Populate available media devices
            await getAvailableMediaDevices();

            // Event listeners
            initiateCallBtn.addEventListener('click', initiateCall);
            endCallBtn.addEventListener('click', endCall);
            toggleAudioBtn.addEventListener('click', toggleAudio);
            toggleVideoBtn.addEventListener('click', toggleVideo);
            testMediaBtn.addEventListener('click', testMediaDevices);
            stopTestBtn.addEventListener('click', stopMediaTest);
            refreshDevicesBtn.addEventListener('click', getAvailableMediaDevices);

            // Listen for device changes
            navigator.mediaDevices.addEventListener('devicechange', async () => {
                log('Media devices changed');
                await getAvailableMediaDevices();
                // Reset selections if devices are removed
                if (!audioInputSelect.value && audioInputSelect.options.length > 0) {
                    audioInputSelect.value = audioInputSelect.options[0].value;
                }
                if (!videoInputSelect.value && videoInputSelect.options.length > 0) {
                    videoInputSelect.value = videoInputSelect.options[0].value;
                }
            });

            updateStatus('Ready to initiate call');
        }

        // Initiate the call
        async function initiateCall() {
            const postId = parseInt(postIdInput.value);
            const acceptorId = acceptorIdInput.value;

            if (!postId || !acceptorId) {
                updateStatus('Please fill in all fields');
                return;
            }

            updateStatus('Initiating call...');
            initiateCallBtn.disabled = true;
            const token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJlOTQxOGRkMi04NzM4LTRkNDMtODM0YS04YTdkMWVkNjdmYzEiLCJlbWFpbCI6InBhdGllbnQxQGV4YW1wbGUuY29tIiwianRpIjoiNWQ2ZjVhMjAtNTZlYi00NDRhLTgyZWItMDYxOTVmNmQxYTE4IiwiaWF0IjoxNzQ1NDQxMDAwLCJyb2xlIjoicGF0aWVudCIsIm5iZiI6MTc0NTQ0MTAwMCwiZXhwIjoxNzQ1NDQ0NjAwLCJpc3MiOiJBc3AubmV0IiwiYXVkIjoiRmx1dHRlckhvc3NhbURldmVsb3BlciJ9.e7LKKn2YltKu35l3Xq-RCHT6ihpKGD3W4vlrgANzAXk"
            try {
                // Call your API endpoint
                //const response = await fetch('/api/video/token', {
                const response = await fetch('/api/calls/initiate-call', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    //body: JSON.stringify({
                    //    identity: postId,
                    //    roomName: acceptorId
                    //})
                    body: JSON.stringify({
                        postId: postId,
                        acceptorId: acceptorId
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API error: ${response.status} - ${errorText}`);
                }

                const data = await response.json();
                log(`Call initiated successfully. Room: ${data.roomName}`);

                // Store the token
                accessToken = data.token;

                // Connect to the Twilio room
                connectToRoom(data.roomName, data.accessToken);

            } catch (error) {
                updateStatus(`Error: ${error.message}`);
                initiateCallBtn.disabled = false;
                log(`Error: ${error.message}`);
            }
        }
        // Add to your JavaScript
        const joinCallBtn = document.getElementById('join-call-btn');
        const roomNameInput = document.getElementById('room-name-input');

        async function joinCall() {
            const roomName = roomNameInput.value;
            const helpertoken ="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJlOTQxOGRkMi04NzM4LTRkNDMtODM0YS04YTdkMWVkNjdmYzEiLCJlbWFpbCI6InBhdGllbnQxQGV4YW1wbGUuY29tIiwianRpIjoiOTY0MGM1YjUtY2QyMS00YmIzLTgwYWUtMWJiMjZiZTFlZmI0IiwiaWF0IjoxNzQ1NDQxMDUwLCJyb2xlIjoicGF0aWVudCIsIm5iZiI6MTc0NTQ0MTA1MCwiZXhwIjoxNzQ1NDQ0NjUwLCJpc3MiOiJBc3AubmV0IiwiYXVkIjoiRmx1dHRlckhvc3NhbURldmVsb3BlciJ9.hDKCd01JZiTmWyEjISi-hMKxV3FK5-Gih9IIX-2BKuY"
            if (!roomName) {
                updateStatus('Please enter a room name');
                return;
            }

            try {
                const response = await fetch('/api/calls/join-call', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${helpertoken}`
                    },
                    body: JSON.stringify({ roomName: roomName })
                });

                const data = await response.json();
                //console.log("join response", data)
                connectToRoom(data.roomName, data.accessToken);
            } catch (error) {
                updateStatus(`Join error: ${error.message}`);
            }
        }

        joinCallBtn.addEventListener('click', joinCall);

        // Connect to Twilio video room
        async function connectToRoom(roomName, token) {
            try {
                updateStatus(`Connecting to room: ${roomName}...`);

                // Get selected devices
                const audioDeviceId = audioInputSelect.value;
                const videoDeviceId = videoInputSelect.value;

                // Request camera/microphone permissions with specific devices
                localTracks = await Twilio.Video.createLocalTracks({
                    audio: audioDeviceId ? { deviceId: { exact: audioDeviceId } } : true,
                    video: videoDeviceId ? { deviceId: { exact: videoDeviceId }, width: 640, height: 480 } : true
                });

                // Display local video
                localTracks.forEach(track => {
                    if (track.kind === 'video') {
                        const videoElement = track.attach();
                        localMediaContainer.appendChild(videoElement);
                    }
                });

                // Connect to the room
                room = await Twilio.Video.connect(token, {
                    name: roomName,
                    tracks: localTracks,
                    bandwidthProfile: {
                        video: {
                            mode: 'collaboration',
                            maxSubscriptionBitrate: 2500000 // 2.5 Mbps
                        }
                    },
                    networkQuality: { local: 1, remote: 1 }
                });

                updateStatus(`Connected to room: ${room.name}`);
                callControls.style.display = 'block';

                // Handle remote participants that are already connected
                room.participants.forEach(participant => {
                    log(`Remote participant ${participant.identity} is already connected`);
                    handleParticipantConnected(participant);
                });

                // Handle participants connecting to the room
                room.on('participantConnected', participant => {
                    log(`Remote participant ${participant.identity} connected`);
                    handleParticipantConnected(participant);
                });

                // Handle participants disconnecting
                room.on('participantDisconnected', participant => {
                    log(`Remote participant ${participant.identity} disconnected`);
                    handleParticipantDisconnected(participant);
                });

                // Handle room disconnection
                room.on('disconnected', handleRoomDisconnected);

                // Handle network quality changes
                room.on('networkQualityLevelChanged', handleNetworkQualityChange);

            } catch (error) {
                updateStatus(`Error connecting to room: ${error.message}`);
                initiateCallBtn.disabled = false;
                log(`Error connecting to room: ${error.name}: ${error.message}`);

                if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                    log('SOLUTION: Please make sure your camera and microphone are properly connected and not in use by another application.');
                } else if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    log('SOLUTION: You need to grant permission to access your camera and microphone. Check your browser settings.');
                } else if (error.name === 'OverconstrainedError') {
                    log('SOLUTION: The requested media settings are not available on your device. Try selecting a different camera/microphone.');
                }
            }
        }

        // Handle network quality changes
        function handleNetworkQualityChange(networkQuality) {
            const quality = networkQuality.quality;
            let qualityText = 'Unknown';

            switch (quality) {
                case 0: qualityText = 'Disconnected'; break;
                case 1: qualityText = 'Very Poor'; break;
                case 2: qualityText = 'Poor'; break;
                case 3: qualityText = 'Fair'; break;
                case 4: qualityText = 'Good'; break;
                case 5: qualityText = 'Excellent'; break;
            }

            log(`Network quality changed: ${qualityText} (${quality})`);
        }

        // Toggle audio
        function toggleAudio() {
            if (!room) return;

            localTracks.forEach(track => {
                if (track.kind === 'audio') {
                    if (isAudioEnabled) {
                        track.disable();
                        toggleAudioBtn.textContent = 'Unmute Audio';
                        log('Audio muted');
                    } else {
                        track.enable();
                        toggleAudioBtn.textContent = 'Mute Audio';
                        log('Audio unmuted');
                    }
                    isAudioEnabled = !isAudioEnabled;
                }
            });
        }

        // Toggle video
        function toggleVideo() {
            if (!room) return;

            localTracks.forEach(track => {
                if (track.kind === 'video') {
                    if (isVideoEnabled) {
                        track.disable();
                        toggleVideoBtn.textContent = 'Turn On Video';
                        log('Video turned off');
                    } else {
                        track.enable();
                        toggleVideoBtn.textContent = 'Turn Off Video';
                        log('Video turned on');
                    }
                    isVideoEnabled = !isVideoEnabled;
                }
            });
        }

        // Handle remote participant connection
        function handleParticipantConnected(participant) {
            log(`Handling new participant: ${participant.identity}`);

            // Handle participant's existing tracks
            participant.tracks.forEach(publication => {
                if (publication.isSubscribed) {
                    handleTrackSubscribed(publication.track);
                }
            });

            // Handle participant's new track subscriptions
            participant.on('trackSubscribed', handleTrackSubscribed);
            participant.on('trackUnsubscribed', handleTrackUnsubscribed);
        }

        // Handle remote track subscription
        function handleTrackSubscribed(track) {
            log(`Track subscribed: ${track.kind}`);
            const element = track.attach();
            if (track.kind === 'video') {
                element.style.width = '100%';
                element.style.height = '100%';
            }
            remoteMediaContainer.appendChild(element);
        }

        // Handle remote track unsubscription
        function handleTrackUnsubscribed(track) {
            log(`Track unsubscribed: ${track.kind}`);
            track.detach().forEach(element => element.remove());
        }

        // Handle participant disconnection
        function handleParticipantDisconnected(participant) {
            log(`Participant ${participant.identity} disconnected`);
            // Remove all participant's track elements
            remoteMediaContainer.innerHTML = '';
        }

        // Handle room disconnection
        function handleRoomDisconnected(room, error) {
            if (error) {
                log(`Room disconnected with error: ${error.message}`);
            }

            // Detach all local media
            room.localParticipant.tracks.forEach(publication => {
                const track = publication.track;
                if (track) {
                    track.stop();
                    track.detach().forEach(element => element.remove());
                }
            });

            // Cleanup any local tracks
            localTracks.forEach(track => {
                track.stop();
                track.detach().forEach(element => element.remove());
            });

            // Reset UI
            localMediaContainer.innerHTML = '';
            remoteMediaContainer.innerHTML = '';
            callControls.style.display = 'none';
            initiateCallBtn.disabled = false;

            // Reset state
            localTracks = [];
            isAudioEnabled = true;
            isVideoEnabled = true;
            toggleAudioBtn.textContent = 'Mute Audio';
            toggleVideoBtn.textContent = 'Turn Off Video';

            updateStatus('Call ended');
            room = null;
        }

        // End the call
        function endCall() {
            if (room) {
                room.disconnect();
                updateStatus('Disconnecting from call...');
            }
        }

        // Initialize the page when loaded
        window.addEventListener('load', init);
    </script>
</body>
</html>